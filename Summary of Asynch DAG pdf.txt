Asynchronous Federated Learning (AFL) has been introduced to improve the efficiency of FL by reducing the
latency of Machine Learning (ML) model aggregation, particularly in the Internet of Things (IoT) environment.

Due to the rapid development of both machine learning (ML) and
Internet of Things (IoT), the massive amounts of data generated by
edge devices, such as smartphones, laptops, and AI speakers, have been
largely exploited to train ML models. To enhance the data privacy and
reduce the latency of training

FL enables the training of a global model by coordinating several
edge devices to perform model training without sharing their raw data.
In FL, each device locally trains the ML model using its dataset, and a centralized server aggregates the learning parameters retrieved from the multiple devices.

Although FL has been extensively studied in many different works,
several challenges still exist, especially in the IoT industry. First, the centralized aggregation server is vulnerable to the single-point-failure issue and several abnormal actions by malicious devices, such as poisoning attacks.

Second, classical synchronous FL has a crit-
ical performance bottleneck, the so-called straggler problem, and it
is challenging to coordinate the FL process entirely because of the
different resources in edge devices, such as central processing unit
(CPU)/memory resources or network bandwidth, particularly in a dy-
namic IoT environment.

To mitigate the aforementioned single-point-failure problem and
anomaly detection issue triggered by a centralized aggregation server,
leveraging blockchain in FL, the so-called blockchained-FL, has been
actively discussed owing to its decentralization and security bene-
fits


Blockchained-FL does not require a
central server for the aggregation. Instead, edge devices communicate
with each other and build the global model in a peer-to-peer manner.
The statement describes the concept of **Blockchained Federated Learning (Blockchained-FL)**, which is a variation of Federated Learning (FL) that utilizes **blockchain technology** to eliminate the need for a central aggregation server. Here’s a detailed explanation:

### Traditional Federated Learning (FL) vs. Blockchained-FL:
1. **Classical Federated Learning**:
   - In traditional FL, edge devices (clients) perform local training on their data and send their updates (such as model parameters or gradients) to a **central server**.
   - The server aggregates these updates, typically using an averaging method, and creates the new global model.
   - This server-centric approach can face problems like:
     - **Single point of failure**: If the server goes down or is compromised, the entire system can fail.
     - **Scalability issues**: A large number of clients sending data to a central server can lead to network congestion or delays.

2. **Blockchained Federated Learning (Blockchained-FL)**:
   - **No central server**: Blockchained-FL does not rely on a central aggregation server. Instead, **blockchain technology** is used to manage the interactions and model updates among the edge devices in a **peer-to-peer** (P2P) manner.
   - **Peer-to-peer communication**: In Blockchained-FL, each edge device communicates directly with other devices. The devices share updates with one another and collaboratively build the global model.
   - **Blockchain for coordination**: Blockchain ensures that the interactions between the devices are secure, transparent, and immutable. The model updates are logged in blocks that are cryptographically linked together, creating a transparent and verifiable record of all updates. Blockchain also provides a **decentralized trust model**, meaning that devices do not need to rely on a single trusted server to aggregate updates.
   
### Key Features and Benefits of Blockchained-FL:
1. **Decentralization**:
   - There is no need for a central server. Each edge device is responsible for its own updates and interacts directly with other devices to share knowledge.
   - This decentralization reduces reliance on a central authority, making the system more **resilient** and **robust** to failures or attacks targeting a central server.

2. **Blockchain for Security and Trust**:
   - Blockchain provides **tamper-proof logs** of all interactions and updates. Each block in the chain contains a record of updates that have been validated by the network, ensuring the **integrity** of the model.
   - This transparency helps in creating trust among edge devices because the updates can be independently verified, and any malicious activity or incorrect updates can be detected.

3. **Incentivization**:
   - In some implementations, **cryptocurrencies** or **tokens** may be used as incentives to encourage devices to contribute to the federated learning process (e.g., by performing local model updates and sharing them). These incentives can be tracked and distributed through the blockchain.
   
4. **Scalability**:
   - Blockchained-FL can be more scalable than traditional FL because there is no central server bottleneck. The devices can interact with each other in a decentralized manner, potentially reducing network congestion and improving overall system efficiency.

5. **Fault Tolerance**:
   - Since there is no single point of failure (as in the case of the central server in traditional FL), the system can be more **fault-tolerant**. If one or more devices fail or become unreliable, the blockchain ensures that the process can continue with other devices.

### Process in Blockchained-FL:
1. **Model Training**: Edge devices train local models on their data.
2. **Model Updates**: Devices periodically share their model updates with others. These updates may include model parameters or gradients.
3. **Blockchain Recording**: These updates are recorded in a blockchain ledger, ensuring traceability and immutability.
4. **Global Model Construction**: The blockchain network can aggregate these updates from all devices, either through consensus mechanisms (e.g., Proof of Work or Proof of Stake) or more advanced distributed aggregation schemes, to construct a global model.

### Challenges of Blockchained-FL:
1. **Blockchain Overhead**: The use of blockchain can introduce additional computational overhead for maintaining the blockchain ledger and verifying transactions. This might be a concern for resource-constrained devices.
2. **Consensus Mechanisms**: Achieving consensus among a large number of devices without a central server can be difficult and may require sophisticated blockchain protocols, such as Proof of Stake (PoS) or other efficient consensus algorithms.
3. **Communication Latency**: Peer-to-peer communication can sometimes lead to increased latency, especially when devices are spread across large networks with variable connectivity.

### Summary:
Blockchained-FL is a decentralized approach to Federated Learning that leverages blockchain technology to remove the need for a central aggregation server. Instead, edge devices collaborate directly with each other, updating and building the global model in a peer-to-peer manner. Blockchain ensures security, transparency, and accountability, and can potentially offer benefits like **fault tolerance**, **scalability**, and **incentivization**. However, it may introduce challenges like computational overhead and communication latency, which must be addressed for efficient operation in real-world scenarios.



On the other hand, as a solution to resolve the straggler problem,
asynchronous FL has recently been introduced,which aggregates a local model asynchronously without waiting for other local models from low-performing devices

As a combination of asynchronous and decentralized FL, a few stud-
ies have proposed the integration of a directed acyclic graph (DAG)-based ledger with FL


Weobserve that the DAG’s inherent property of network asynchrony (Zhao& Yu, 2019) naturally enables flexible integration of asynchronous FL,because a DAG network itself can tolerate the stale transaction, which is a critical prerequisite of asynchronous FL. In Section 4, we further discuss our integration motivation.




2.1. Blockchain and DAG
Blockchain is a distributed ledger to maintain tamper-proof transaction records. Blockchain utilizes cryptographic techniques to function
as an immutable database managed by decentralized entities in a peer-
to-peer manner. In a blockchain system, every node in the decentralized
network must agree on the same state of the database for every round.
Therefore, a consensus mechanism to create a block, which means to
agree on the state, is one of the primary components of the blockchain
system.

Proof-of-work (PoW) is a conventional consensus mechanism, which
is suggested from a whitepaper on Bitcoin. The author shows that the
blockchain would be probabilistically tamper-proof if the hash rate of
the malicious node is lower than that of the honest nodes (Nakamoto,
2008). The blockchain system implemented in Bitcoin considers two
distinctive players: those who issue transactions and those who approve
transactions.


The statement you provided addresses a key challenge in **classical synchronous Federated Learning (FL)**, which is the **straggler problem**. Here's a breakdown of the concepts:

1. **Classical Synchronous Federated Learning**:
   - In synchronous Federated Learning, all participating devices (or clients) perform computations (e.g., model training) locally and send their updates (e.g., gradients) to a central server. After the server aggregates the	 updates, it broadcasts the new global model to all clients.
   - This process repeats iteratively.

2. **Straggler Problem**:
   - The **straggler problem** refers to the situation where some clients are significantly slower than others in completing their tasks, such as training their models or sending updates. These slower clients are called **stragglers**.
   - In synchronous FL, all clients must finish their updates before the server can aggregate the results and proceed. If one or more clients are slow, it delays the entire process, leading to inefficiency.
   - Stragglers can arise due to various factors, such as:
     - **Limited hardware resources** (CPU, memory) on edge devices.
     - **Low network bandwidth**, which can cause delays in data transfer between the devices and the central server.
     - **Dynamic environments**, such as in the **Internet of Things (IoT)**, where devices may be mobile, have varying computational capacities, or operate in environments with unstable network conditions.

3. **Challenges in Coordinating the Federated Learning Process**:
   - **Resource heterogeneity**: The resources (e.g., processing power, memory) on edge devices vary significantly. Some devices may be more powerful and able to process data faster, while others may be resource-constrained, slowing down the training process.
   - **Network heterogeneity**: The network bandwidth available to each client can vary, leading to delays in sending and receiving updates. In real-world IoT environments, this becomes even more problematic because devices are often spread out and connected through unreliable or low-speed networks.
   - **Dynamic environments**: In IoT, devices are often mobile or intermittently connected, and the network conditions can change unpredictably. This adds complexity to synchronizing the FL process across all devices.

### Impact of the Straggler Problem:
- The straggler problem can lead to **inefficiency** and **slower convergence** of the Federated Learning model because the server has to wait for the slowest client to finish its computation before proceeding with the next round of training.
- This **synchronization bottleneck** can reduce the overall effectiveness of Federated Learning, particularly in large-scale and dynamic IoT settings.

### Solutions:
- **Asynchronous FL**: One approach to mitigate this problem is to use asynchronous FL, where devices can send their updates as soon as they are ready, rather than waiting for all clients to complete their computations simultaneously.
- **Straggler mitigation strategies**: Techniques such as **client selection** (only using the fastest clients for a particular round), **partial aggregation**, or **differential updates** can be employed to reduce the impact of stragglers.

In summary, the straggler problem in synchronous Federated Learning arises due to resource and network variability among edge devices, especially in dynamic IoT environments. It creates a bottleneck that can reduce the overall performance and efficiency of the FL process.



The statement describes **blockchain** as a **distributed ledger** and outlines the key components of how blockchain systems work. Here's a breakdown of each concept:

### Key Concepts Explained:

1. **Distributed Ledger**:
   - A **distributed ledger** is a database that is shared and synchronized across multiple devices or nodes in a network, rather than being stored on a single central server. This means that there is no single point of control, and each node (or participant) in the network has a copy of the ledger.
   - This distributed nature ensures **redundancy** and **resilience** because if one node fails or is compromised, the other nodes still hold the correct copy of the ledger.

2. **Tamper-Proof Transaction Records**:
   - Blockchain provides a **tamper-proof** system for storing transaction records. This means that once a transaction is added to the blockchain, it cannot be altered or deleted without detection. This **immutability** is achieved through cryptographic techniques, which securely link the blocks in the chain.
   - Each block contains a hash (a unique cryptographic fingerprint) of the previous block, creating a **chain**. This structure ensures that changing one block would require changing all subsequent blocks, making tampering extremely difficult.

3. **Cryptographic Techniques**:
   - Blockchain uses **cryptography** to ensure the **security** and **integrity** of the data. This includes techniques like:
     - **Hashing**: A cryptographic function that takes input data (like a transaction) and produces a fixed-size output (the hash). The hash is unique to the input data, and even a small change in the input will result in a drastically different hash.
     - **Digital Signatures**: Used to authenticate the identity of the parties involved in a transaction and ensure that the transaction has not been altered.
   - These cryptographic methods are crucial for ensuring that transactions are secure, private, and tamper-resistant.

4. **Immutable Database**:
   - The blockchain is referred to as an **immutable database** because once data is recorded, it cannot be changed or deleted without consensus from the network. This immutability is a key feature that differentiates blockchain from traditional databases.
   - This feature is important for ensuring the trustworthiness and reliability of the information stored in the blockchain.

5. **Decentralized Entities in a Peer-to-Peer Manner**:
   - In a blockchain system, there is no central authority controlling the database. Instead, the database is managed by **decentralized entities** (also called **nodes**), which are peers in the network. Each node has an identical copy of the blockchain.
   - The decentralized nature of the network means that no single participant can unilaterally alter the blockchain. The control is distributed across all participants, which enhances security and reduces the risk of fraud or censorship.

6. **Consensus Mechanism**:
   - A **consensus mechanism** is a protocol that ensures all nodes in the network agree on the current state of the blockchain and the validity of transactions. Since the network is decentralized and there is no central authority, the consensus mechanism is critical to ensuring that all participants trust the data in the blockchain.
   - Consensus mechanisms can vary, but some of the most common ones are:
     - **Proof of Work (PoW)**: Used by Bitcoin, where nodes (miners) solve complex mathematical problems to validate transactions and create new blocks. The first node to solve the problem gets to add the block to the blockchain.
     - **Proof of Stake (PoS)**: Used by other blockchains like Ethereum 2.0, where nodes (validators) are selected to create new blocks based on the amount of cryptocurrency they hold and are willing to "stake" as collateral.
     - **Practical Byzantine Fault Tolerance (PBFT)**: Used by some permissioned blockchains, where a certain percentage of nodes must agree on the validity of a transaction before it is added to the blockchain.
   - The **consensus mechanism** ensures that all nodes in the decentralized network reach an agreement on the state of the blockchain (i.e., the current set of valid transactions) after every round.

7. **Creating a Block**:
   - A **block** is a group of transactions that are bundled together and added to the blockchain. To create a block, nodes in the network must reach consensus on which transactions are valid and should be included in the block.
   - Once consensus is reached, the block is added to the blockchain, and the transaction records within that block are considered final and immutable.

### Why Consensus Is Important:
- **Agreement on State**: Since the blockchain is decentralized, **every node** must have the same version of the blockchain (i.e., agree on the same transaction history). The consensus mechanism ensures that all nodes agree on the **validity** of transactions and that no one can manipulate the ledger without the agreement of the majority of the network.
  
- **Preventing Double-Spending**: In cryptocurrency systems, the consensus mechanism helps prevent problems like **double-spending**, where the same funds are spent twice. By ensuring all transactions are validated and agreed upon by the network, consensus prevents this fraud.

- **Security and Trust**: The consensus mechanism helps ensure the **security** of the blockchain, making it resistant to attacks and ensuring that the data recorded on the blockchain is trustworthy. This is particularly important in applications like cryptocurrency, supply chain tracking, and secure voting systems, where the integrity of data is paramount.

### Summary:
Blockchain is a decentralized, tamper-proof distributed ledger system that uses **cryptographic techniques** to securely record transactions in an immutable way. It is maintained by a network of **decentralized entities (nodes)**, and every node must agree on the current state of the blockchain through a **consensus mechanism**. This consensus mechanism ensures that transactions are valid, prevents fraud, and allows the blockchain to remain secure, transparent, and trustworthy. The consensus process is fundamental to the operation of blockchain, ensuring that all participants in the network are in agreement regarding the ledger’s state and preventing manipulation of the data.




To explain the **advantages of DAG-based systems** with an analogy, let's use a **conveyor belt system** in a factory. Imagine that the factory produces **products** (transactions), and the factory floor represents the **ledger** where all these products must be processed and confirmed.

### 1. **Scalability (Handling more transactions per second)**:
   - **Traditional Blockchain**: In a traditional blockchain system, like a **blockchain factory** where products (transactions) come off a single assembly line (blockchain). For every batch of products, all workers must wait for the assembly line to finish the current batch (block) before they can start working on the next one. As more products come in, the line becomes congested, and waiting times increase. This is why traditional blockchains can become slower as more transactions are added.
   
   - **DAG (Tangle in IOTA)**: In a **DAG-based factory**, instead of a single assembly line, there are multiple parallel **conveyor belts**. Each product (transaction) can go through its own line without waiting for others. As new products arrive, they don't have to wait for a single line to finish. More workers (nodes) can work on products at the same time, leading to faster processing and higher throughput (more transactions per second).

   - **Analogy**: Think of a traditional blockchain as a single conveyor belt with limited space for workers to handle products. The more workers you have, the more congested the line becomes. A DAG-based factory has multiple conveyor belts, allowing many products to be processed at once, and as the factory gets more workers (nodes), the processing speed increases without slowing down.

### 2. **No Miners Required (Energy Efficiency)**:
   - **Traditional Blockchain**: In a traditional blockchain like **Bitcoin**, the factory requires a specialized worker (miner) to verify and validate each batch of products (transactions). These miners do heavy, energy-intensive work (Proof of Work), ensuring that only valid products make it to the assembly line. This process uses a lot of energy and resources.
   
   - **DAG (Tangle in IOTA)**: In a DAG-based factory like **IOTA**, **every worker** (participant or node) contributes to the validation process. When a new product (transaction) arrives, instead of having a miner verifying it, the workers verify it by checking the validity of previous products. This way, no specialized workers (miners) are needed, and the energy consumption is much lower because it's distributed among all participants.

   - **Analogy**: Imagine the traditional factory has a specific worker (miner) who must check each batch of products, consuming a lot of energy. In the DAG-based factory, all workers (nodes) pitch in and verify the products collaboratively, without needing one central worker doing all the heavy lifting. This makes the process more efficient and energy-saving.

### 3. **Faster Transactions (Parallel Processing)**:
   - **Traditional Blockchain**: In a traditional system, all transactions are grouped into a **block** and processed in a linear fashion. Each batch of transactions has to wait for the previous block to be verified and confirmed before a new one can be added. This makes the confirmation process slow, especially when the system is congested.
   
   - **DAG (Tangle in IOTA)**: In a DAG system, there is no need to group transactions into blocks. Instead, transactions are processed **independently** and can be confirmed in parallel. Once a new transaction is created, it can independently refer to previous transactions, and the system will process them simultaneously. This results in **faster** confirmation times since the system doesn't have to wait for blocks to be formed.

   - **Analogy**: Think of the traditional blockchain factory as needing to complete one batch of products before starting another, which causes delays. The DAG-based factory can process many batches of products simultaneously without waiting for others to finish, making it much faster and more efficient.

### Summary:
- **Scalability**: DAG allows multiple transactions to be processed simultaneously, just like a factory with multiple conveyor belts working at once.
- **No Miners Required**: In DAG, participants validate transactions by referring to previous ones, reducing the need for energy-consuming miners, just like a factory where all workers check the quality of products instead of one specific worker doing all the work.
- **Faster Transactions**: DAG processes transactions in parallel without needing to wait for blocks, similar to a factory where multiple production lines work independently to speed up the process.



Let's clarify how **workers (nodes)** in a **DAG-based system** like **IOTA** can validate transactions by checking the **validity of previous transactions**. 

### In Traditional Blockchain (Bitcoin as an example):
- A **miner** verifies transactions by solving a **complex mathematical puzzle** (called Proof of Work). Once the miner solves the puzzle, they add a new **block** of transactions to the blockchain. The miner gets rewarded for this work.
- In this system, only the **miner** does the work of verifying transactions and adding them to the blockchain.

### In DAG-based Systems (like **IOTA** with the **Tangle**):
- In IOTA, instead of having a central miner, **every participant (worker/node)** validates transactions. The process is a bit different from blockchain because **transactions themselves are directly linked to previous transactions**, not blocks.

### How Does the Validation Process Work in IOTA (Tangle)?
Here’s how workers (nodes) verify a new transaction in **IOTA**:

1. **New Transaction (Worker's Task)**:
   - Imagine a new **transaction (product)** is created. This transaction needs to be added to the ledger (Tangle).
   - Before it can be added, the **worker (node)** who wants to add this new transaction has to make sure that it is **valid** and that it does not conflict with the earlier transactions already in the system.

2. **Checking Previous Transactions (Validating with History)**:
   - Instead of waiting for a central authority (like a miner) to check the validity, the worker who wants to add the new transaction has to **refer to two previous transactions** (products) that are already in the ledger.
   - This means the worker **references two earlier transactions** and checks if they are valid. For example, the worker may check:
     - Whether the transactions referenced are correctly signed by the correct participants.
     - Whether the transactions are not fraudulent or double-spent (i.e., the same funds being spent twice).

3. **"Voting" on Validity**:
   - To add a new transaction, the worker **votes** for the validity of these two previous transactions by referencing them in their own transaction. The worker is essentially saying, "I confirm that these two transactions are valid, and I am including them in my transaction."
   - This creates a **network of dependencies**: each transaction points to (references) earlier transactions, and in this way, the entire system works in a web-like structure where each new transaction contributes to verifying and validating the previous ones.

4. **No Need for Miners**:
   - This system eliminates the need for **miners** to process each transaction because **every worker** contributes to validating the ledger.
   - The validation of new transactions is distributed across all participants (nodes), reducing energy consumption and speeding up the process.

### Simplified Analogy:
Imagine a **group of workers** in a warehouse, each working on different products (transactions). Whenever a worker (node) wants to add a new product (transaction) to the warehouse (ledger), they **check two previously processed products** (referenced transactions) to make sure they are valid — for example, by confirming they have the right labels or certifications (authenticity). 

- If the worker finds the previous products valid, they add their product to the warehouse and **certify** that the earlier products were valid.
- Every worker in the warehouse does this for every new product, which means there is no need for a single special worker (miner) to check all the products. Instead, **all workers help with validation**, making the system **efficient and decentralized**.

### Why is this approach important?
- **Energy Efficiency**: Since there are no miners, the process of verifying transactions (like checking product validity) is done collaboratively by all participants, which is more **energy-efficient**.
- **Scalability**: As more workers (nodes) join, the system can handle more transactions, and the process becomes faster and more efficient because each new worker contributes to the validation process.

### Summary:
In **IOTA (Tangle)**, when a new transaction is created, the **worker (node)** adds it by validating two previous transactions, ensuring they are legitimate. This eliminates the need for specialized miners and allows the system to function in a decentralized, efficient way, where all workers participate in the process of validating transactions.



The
tangle, a directed acyclic graph, consists of vertices and directed edges,
where the vertices are transactions, and the directed edges are approvals of other transactions.


Every incoming transaction in IOTA needs
to approve two unapproved transactions, so-called tips, and each node
selects two transactions to approve by a tip selection algorithm
